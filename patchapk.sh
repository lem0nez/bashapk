#!/usr/bin/env bash

# Copyright Â© 2020 Nikita Dudko. All rights reserved.
# Contacts: <nikita.dudko.95@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -eo pipefail
shopt -s globstar nullglob

TMP_FILE=$(mktemp -t tmp.patchapk-XXXXXX)
cleanup() {
  rm -f "$TMP_FILE"
}
trap cleanup EXIT

main() {
  unset TRASH_DIR

  SCRIPT_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
  DATA_DIR="$SCRIPT_DIR/data"

  if [[ ! -d $DATA_DIR ]]; then
    echo >&2 'Could not find data directory!'
    exit 1
  elif [[ -z $1 ]]; then
    print_help
    exit 0
  fi

  while [[ -n $1 && -z $patch ]]; do
    case $1 in
      -h|--help)
        print_help
        exit 0 ;;
      -t|--trash)
        shift
        if [[ -z $1 ]]; then
          echo >&2 'Specify a directory for trash!'
          exit 1
        elif [[ ! -d $1 ]]; then
          printf >&2 'Directory "%s" does not exist!\n' "$1"
          exit 1
        fi
        TRASH_DIR=$1 ;;
      -*)
        printf >&2 'Unrecognized option: %s\n' "$1"
        exit 1 ;;
      *)
        patch=$1 ;;
    esac
    shift
  done

  if [[ -z $patch ]]; then
    echo >&2 'Specify a patch!'
    exit 1
  fi

  for p in "$SCRIPT_DIR"/patches/*.sh; do
    # shellcheck --source-path=patches
    . "$p"
  done

  case $patch in
    rm-debug-info|rm-ads|rm-analytics|rm-langs|rm-dummies|no-billing)
      provide_dirs= ;;
    *)
      printf >&2 'Unrecognized patch: %s\n' "$patch"
      exit 1 ;;
  esac

  if [[ -n ${provide_dirs+SET} ]]; then
    if [[ -z $1 ]]; then
      echo >&2 'Specify at least one directory!'
      exit 1
    fi

    while [[ -n $1 ]]; do
      if [[ ! -d $1 ]]; then
        printf >&2 'Directory "%s" does not exist! Skipping...\n' "$1"
      else
        "${patch//-/_}" "$1"
      fi
      shift
    done
  fi

  exit 0
}

print_help() {
  printf 'Usage: %s [options...] [patch] ...\n'`
      `'\n'`
      `'Options:\n'`
      `'  -h, --help           Print the help message\n'`
      `'  -t, --trash [dir]    Set a directory for trash\n'`
      `'\n'`
      `'Patches:\n'`
      `'  rm-debug-info [smali...]      Remove the debugging information in\n'`
      `'                                all files from the smali folder(s)\n'`
      `'  rm-ads [APK root...]          Remove ads\n'`
      `'  rm-analytics [APK root...]    Disable analytic reports\n'`
      `'  rm-langs [resources...]       Remove languages that does not match\n'`
      `'                                the KEEP_LANG pattern (inside the\n'`
      `'                                patch script)\n'`
      `'  rm-dummies [resources...]     Remove unnecessary "dummies"\n'`
      `'                                generated by the ApkTool\n'`
      `'  no-billing [APK root...]      Disable the billing service\n'` \
      "$0"
}

# Utilities

# Function returns the regex pattern of list.
# Takes a path of the list file (relative to the data directory).
get_list_pattern() {
  mapfile -t array < "$DATA_DIR/$1"
  IFS='|' pattern="(${array[*]})"
  echo "$pattern"
}

# Replace strings in the smali code. Function takes the following parameters:
# 1. search pattern (make sure that pattern
#    doesn't match text outside the quotes);
# 2. replacement pattern;
# 3. boolean value: true for case sensative search and false otherwise;
# 4. paths.
#
# Notice: you should escape the number signs ('#')
# in patterns if you want to use them.
replace_strings() {
  search_pattern="([^[:space:]\"]+\s*)\"$1\"\s*$"; shift
  replacement_pattern="\\1\"$1\""; shift
  is_case_sensetive=$1; shift

  if [[ $is_case_sensetive == true ]]; then
    grep_pattern_options='E'
    sed_flags='g'
  else
    grep_pattern_options='iE'
    sed_flags='Ig'
  fi

  while read -r f; do
    if [[ -n $f ]]; then
      # Just print a matched line.
      grep -nH"$grep_pattern_options" "$search_pattern" "$f"
      sed -ri "s#$search_pattern#$replacement_pattern#$sed_flags" "$f"
    fi
  done <<< "$(grep -rl"$grep_pattern_options" "$search_pattern" "$@")"
}

# Remove the matched components from the manifest file. Parameters:
# 1. component name pattern (make sure that pattern
#    doesn't match text outside the quotes);
# 2. file path.
remove_manifest_components() {
  pattern="^[[:space:]]*<(activity|provider|receiver|service)"`
      `"[[:space:]].*android:name=\"$1\""
  file=$2

  unset line_number skip_line component_scope file_changed
  : > "$TMP_FILE"

  while IFS= read -r l; do
    line_number=$((line_number + 1))

    if [[ "$l" =~ $pattern ]]; then
      if [[ "$l" =~ (/>[[:space:]]*$) ]]; then
        # Skip only this line, as component has no child element(s).
        skip_line=
      else
        # Get the component type.
        component_scope=$(sed -r 's/^\s*<([a-z]+)\s+.+$/\1/' <<< "$l")
      fi
    fi

    # If component has child element(s)...
    if [[ -n ${component_scope+SET} ]]; then
      # If it's a closing tag of component...
      if [[ "$l" =~ (^[[:space:]]*</$component_scope>[[:space:]]*$) ]]; then
        unset component_scope
      fi
      skip_line=
    fi

    if [[ -n ${skip_line+SET} ]]; then
      unset skip_line
      echo "$file:$line_number:$l"
      file_changed=
    else
      echo "$l" >> "$TMP_FILE"
    fi
  done < "$file"

  if [[ -n ${file_changed+SET} ]]; then
    cat "$TMP_FILE" > "$file"
  fi
}

main "$@"
